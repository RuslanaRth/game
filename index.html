<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<title>Ken — test levels</title>
<style>
  html,body {height:100%; margin:0; background:#000;}
  #gameCanvas {
    display:block; 
    width: 100vw;
    height: 100vh;
    background:#222;
  }
  #overlay {position:fixed; left:10px; top:10px; color:#fff; font-family: monospace; background:rgba(0,0,0,0.6); padding:6px; border-radius:6px;}
  #errors {position:fixed; right:10px; top:10px; color:#fff; font-family:monospace; background:rgba(128,0,0,0.6); padding:6px; border-radius:6px; display:none;}
</style>
</head>
<body>
<canvas id="gameCanvas" width="900" height="500"></canvas>
<div id="overlay">Загрузка ресурсов...</div>
<div id="errors"></div>

<script>
/* ------------- Настройки и список файлов ------------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const errorsBox = document.getElementById('errors');

const IMAGES = {
  back1: 'back1.jpg',
  back2: 'back2.jpg',
  back3: 'back3.jpg',
  idle: 'idle.png',
  idle2: 'idle2.png',
  walk1: 'walk1.png',
  walk2: 'walk2.png',
  punch: 'punch.png',
  mushidle1: 'mushidle1.png',
  mushidle2: 'mushidle2.png',
  mushpunch: 'mushpunch.png',
  mushdeath: 'mushdeath.png'
};

/* ------------- Встроенные звуковые эффекты ------------- */
function createSound(frequency, duration, type = 'sine') {
  try {
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.type = type;
    oscillator.frequency.value = frequency;
    gainNode.gain.setValueAtTime(0.7, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    oscillator.start();
    oscillator.stop(audioContext.currentTime + duration);
  } catch (e) {
    console.log('Audio not supported:', e);
  }
}

function playSound(soundName) {
  switch(soundName) {
    case 'punch':
      createSound(150, 0.1, 'square'); // Низкий звук удара
      break;
    case 'enemy_hit':
      createSound(300, 0.2, 'sawtooth'); // Звук попадания
      break;
    case 'enemy_death':
      createSound(200, 0.5, 'sine'); // Длинный звук смерти
      break;
  }
}

/* ------------- Загрузка с обработкой ошибок ------------- */
let images = {};
let missing = [];

function loadImage(key, src) {
  return new Promise(resolve => {
    const img = new Image();
    img.onload = () => { images[key] = img; resolve({ok:true,key}); };
    img.onerror = () => { missing.push(src); images[key] = null; resolve({ok:false,key}); };
    img.src = src;
  });
}

async function preloadAll() {
  overlay.textContent = 'Загружаю ресурсы...';
  const promises = Object.entries(IMAGES).map(([k,s]) => loadImage(k,s));
  await Promise.all(promises);
  if (missing.length) {
    errorsBox.style.display = 'block';
    errorsBox.textContent = 'Не загружены: ' + missing.join(', ');
  } else {
    errorsBox.style.display = 'none';
  }
  overlay.textContent = 'Нажми стрелки ← → для движения, Space — удар. Дошёл до правого края — переход на следующий уровень.';
}

/* ------------- Игровые сущности ------------- */
let page = 1; // <── ВАЖНО: теперь переменная наверху

const ken = {
  x: 50, y: canvas.height - 200, w: 200, h: 200,
  vx: 5,
  action: 'idle', frame:0, animTimer:0,
  facing: 'right'
};

// Злодеи для каждого уровня
const enemies = {
  level2: {
    x: 600, y: canvas.height - 200, w: 200, h: 200,
    hp: 5, alive: true, action:'idle', frame:0, animTimer:0,
    hitTimer: 0
  },
  level3: [
    {
      x: 400, y: canvas.height - 200, w: 200, h: 200,
      hp: 5, alive: true, action:'idle', frame:0, animTimer:0,
      hitTimer: 0
    },
    {
      x: 700, y: canvas.height - 200, w: 200, h: 200,
      hp: 5, alive: true, action:'idle', frame:0, animTimer:0,
      hitTimer: 0
    }
  ]
};
/* ------------- Управление клавишами ------------- */
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'Space') e.preventDefault();
});
window.addEventListener('keyup', e => { keys[e.code] = false; });

/* ------------- Логика столкновения ------------- */
function isColliding(a,b) {
  return !(a.x + a.w < b.x  a.x > b.x + b.w  a.y + a.h < b.y || a.y > b.y + b.h);
}

/* ------------- Отрисовка персонажа ------------- */
function drawKen() {
  const imgSet = (ken.action === 'walk') ? [images.walk1, images.walk2]
                : (ken.action === 'punch') ? [images.punch]
                : [images.idle, images.idle2];

  ken.animTimer++;
  if (ken.animTimer > 10) { ken.animTimer = 0; ken.frame = (ken.frame+1) % imgSet.length; }

  const img = imgSet[ken.frame];
  if (img) {
    ctx.save();
    if (ken.facing === 'left') {
      ctx.scale(-1, 1);
      ctx.drawImage(img, -ken.x - ken.w, ken.y, ken.w, ken.h);
    } else {
      ctx.drawImage(img, ken.x, ken.y, ken.w, ken.h);
    }
    ctx.restore();
  }
}

/* ------------- Отрисовка врага ------------- */
function drawEnemy(enemy) {
  if (!enemy.alive) return;
  
  const imgSet = (enemy.action === 'punch') ? [images.mushpunch]
                : [images.mushidle1, images.mushidle2];

  enemy.animTimer++;
  if (enemy.animTimer > 12) { enemy.animTimer = 0; enemy.frame = (enemy.frame+1) % imgSet.length; }

  const img = imgSet[enemy.frame];
  if (img) {
    ctx.drawImage(img, enemy.x, enemy.y, enemy.w, enemy.h);
  }
}

/* ------------- Отрисовка праха (отдельно) ------------- */
function drawDeathEffects() {
  if (page === 2 && !enemies.level2.alive) {
    if (images.mushdeath) {
      ctx.drawImage(images.mushdeath, enemies.level2.x, enemies.level2.y, enemies.level2.w, enemies.level2.h);
    }
  }
  
  if (page === 3) {
    enemies.level3.forEach(enemy => {
      if (!enemy.alive && images.mushdeath) {
        ctx.drawImage(images.mushdeath, enemy.x, enemy.y, enemy.w, enemy.h);
      }
    });
  }
}

/* ------------- Обновление состояния ------------- */
function update() {
  if (keys['ArrowRight']) {
    ken.x += ken.vx;
    ken.action = 'walk';
    ken.facing = 'right';
  } else if (keys['ArrowLeft']) {
    ken.x -= ken.vx;
    ken.action = 'walk';
    ken.facing = 'left';
  } else {
    if (ken.action !== 'punch') ken.action = 'idle';
  }

  ken.x = Math.max(0, Math.min(canvas.width - ken.w, ken.x));

  if (keys['Space']) {
    if (ken.action !== 'punch') {
      ken.action = 'punch';
      playSound('punch');
      
      if (page === 2 && enemies.level2.alive && isColliding(ken, enemies.level2)) {
        enemies.level2.hp -= 1;
        enemies.level2.action = 'punch';
        enemies.level2.hitTimer = 20;
        playSound('enemy_hit');
        
        if (enemies.level2.hp <= 0) {
          enemies.level2.alive = false;
          playSound('enemy_death');
        }
      }
      
      if (page === 3) {
        enemies.level3.forEach(enemy => {
          if (enemy.alive && isColliding(ken, enemy)) {
            enemy.hp -= 1;
            enemy.action = 'punch';
            enemy.hitTimer = 20;
            playSound('enemy_hit');
            
            if (enemy.hp <= 0) {
              enemy.alive = false;
              playSound('enemy_death');
            }
          }
        });
      }
      
      setTimeout(() => { 
        if (ken.action === 'punch') ken.action = 'idle'; 
      }, 220);
    }
    keys['Space'] = false;
  }

  if (page === 2 && enemies.level2.hitTimer > 0) {
    enemies.level2.hitTimer--;
    if (enemies.level2.hitTimer === 0 && enemies.level2.alive) {
      enemies.level2.action = 'idle';
    }
  }
  
  if (page === 3) {
    enemies.level3.forEach(enemy => {
      if (enemy.hitTimer > 0) {
        enemy.hitTimer--;
        if (enemy.hitTimer === 0 && enemy.alive) {
          enemy.action = 'idle';
        }
      }
    });
  }  
  if (page === 1 && ken.x >= canvas.width - ken.w - 10) {
    page = 2;
    ken.x = 40;
  }
  
  if (page === 2 && ken.x >= canvas.width - ken.w - 10 && !enemies.level2.alive) {
    page = 3;
    ken.x = 40;
  }
}

/* ------------- Рендер сцены ------------- */
function render() {
  const bg = (page === 1) ? images.back1 : 
             (page === 2) ? images.back2 : images.back3;
             
  if (bg) {
    ctx.drawImage(bg, 0, 0, canvas.width, canvas.height);
  } else {
    ctx.fillStyle = page === 1 ? '#446' : 
                   page === 2 ? '#264' : '#624';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  drawDeathEffects();

  if (page === 2 && enemies.level2.alive) {
    drawEnemy(enemies.level2);
  } else if (page === 3) {
    enemies.level3.forEach(enemy => {
      if (enemy.alive) {
        drawEnemy(enemy);
      }
    });
  }

  drawKen();

  ctx.fillStyle = 'rgba(0,0,0,0.6)'; 
  ctx.fillRect(8, 8, 120, 40);
  ctx.fillStyle = '#fff'; 
  ctx.font = '16px monospace';
  ctx.fillText('Уровень: ' + page, 12, 26);
  
  if (page === 2 && enemies.level2.alive) {
    ctx.fillText('HP: ' + enemies.level2.hp, 12, 50);
  }
  
  if (page === 3) {
    const aliveEnemies = enemies.level3.filter(e => e.alive).length;
    ctx.fillText('Врагов: ' + aliveEnemies, 12, 50);
  }
}

/* ------------- Игровой цикл ------------- */
function loop() {
  update();
  render();
  requestAnimationFrame(loop);
}

/* ------------- Старт ------------- */
preloadAll().then(() => {
  overlay.style.display = 'none';
  loop();
});
</script>
</body>
</html>
