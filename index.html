<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8"/>
<title>Ken — test levels</title>
<style>
  html,body {height:100%; margin:0; background:#000;}
  #gameCanvas {
    display:block; 
    width: 100vw;
    height: 100vh;
    background:#222;
  }
  #overlay {position:fixed; left:10px; top:10px; color:#fff; font-family: monospace; background:rgba(0,0,0,0.6); padding:6px; border-radius:6px;}
  #errors {position:fixed; right:10px; top:10px; color:#fff; font-family:monospace; background:rgba(128,0,0,0.6); padding:6px; border-radius:6px; display:none;}
</style>
</head>
<body>
<canvas id="gameCanvas" width="900" height="500"></canvas>
<div id="overlay">Загрузка ресурсов...</div>
<div id="errors"></div>

<script>
/* ------------- Настройки и список файлов ------------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const errorsBox = document.getElementById('errors');

const IMAGES = {
  back1: 'back1.jpg',
  back2: 'back2.jpg',
  back3: 'back3.jpg',
  idle: 'idle.png',
  idle2: 'idle2.png',
  walk1: 'walk1.png',
  walk2: 'walk2.png',
  punch: 'punch.png',
  mushidle1: 'mushidle1.png',
  mushidle2: 'mushidle2.png',
  mushpunch: 'mushpunch.png',
  mushdeath: 'mushdeath.png'
};

/* ------------- Загрузка с обработкой ошибок ------------- */
let images = {};
let missing = [];

function loadImage(key, src) {
  return new Promise(resolve => {
    const img = new Image();
    img.onload = () => { images[key] = img; resolve({ok:true,key}); };
    img.onerror = () => { missing.push(src); images[key] = null; resolve({ok:false,key}); };
    img.src = src;
  });
}

async function preloadAll() {
  overlay.textContent = 'Загружаю ресурсы...';
  const promises = Object.entries(IMAGES).map(([k,s]) => loadImage(k,s));
  await Promise.all(promises);
  if (missing.length) {
    errorsBox.style.display = 'block';
    errorsBox.textContent = 'Не загружены: ' + missing.join(', ');
  } else {
    errorsBox.style.display = 'none';
  }
  overlay.textContent = 'Нажми стрелки ← → для движения, Space — удар. Дошёл до правого края — переход на следующий уровень.';
}

/* ------------- Игровые сущности ------------- */
const ken = {
  x: 50, y: canvas.height - 200, w: 200, h: 200,
  vx: 5,
  action: 'idle', frame:0, animTimer:0,
  facing: 'right'
};

// Злодеи для каждого уровня
const enemies = {
  level2: {
    x: 600, y: canvas.height - 200, w: 200, h: 200,
    hp: 5, alive: true, action:'idle', frame:0, animTimer:0,
    hitTimer: 0
  },
  level3: [
    {
      x: 400, y: canvas.height - 200, w: 200, h: 200,
      hp: 5, alive: true, action:'idle', frame:0, animTimer:0,
      hitTimer: 0
    },
    {
      x: 700, y: canvas.height - 200, w: 200, h: 200,
      hp: 5, alive: true, action:'idle', frame:0, animTimer:0,
      hitTimer: 0
    }
  ]
};

let page = 1; // 1, 2 или 3
let deathEffects = []; // Массив для эффектов смерти

/* ------------- Управление клавишами ------------- */
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'Space') e.preventDefault();
});
window.addEventListener('keyup', e => { keys[e.code] = false; });

/* ------------- Логика столкновения ------------- */
function isColliding(a, b) {
  return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
}

/* ------------- Отрисовка персонажа ------------- */
function drawKen() {
  const imgSet = (ken.action === 'walk') ? [images.walk1, images.walk2]
                : (ken.action === 'punch') ? [images.punch]
                : [images.idle, images.idle2];

  ken.animTimer++;
  if (ken.animTimer > 10) { ken.animTimer = 0; ken.frame = (ken.frame+1) % imgSet.length; }

  const img = imgSet[ken.frame];
  if (img) {
    ctx.save();
    if (ken.facing === 'left') {
      ctx.scale(-1, 1);
      ctx.drawImage(img, -ken.x - ken.w, ken.y, ken.w, ken.h);
    } else {
      ctx.drawImage(img, ken.x, ken.y, ken.w, ken.h);
    }
    ctx.restore();
  }
}
 /* ------------- Отрисовка врага ------------- */
function drawEnemy(enemy) {
  if (!enemy.alive) {
    // Рисуем прах после смерти
    if (images.mushdeath) {
      ctx.drawImage(images.mushdeath, enemy.x, enemy.y, enemy.w, enemy.h);
    } else {
      ctx.fillStyle = '#666666';
      ctx.fillRect(enemy.x, enemy.y, enemy.w, enemy.h);
      ctx.fillStyle = '#ffffff';
      ctx.font = '16px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('ПРАХ', enemy.x + enemy.w/2, enemy.y + enemy.h/2);
      ctx.textAlign = 'left';
    }
    return;
  }
  
  const imgSet = (enemy.action === 'punch') ? [images.mushpunch]
                : [images.mushidle1, images.mushidle2];

  enemy.animTimer++;
  if (enemy.animTimer > 12) { enemy.animTimer = 0; enemy.frame = (enemy.frame+1) % imgSet.length; }

  const img = imgSet[enemy.frame];
  if (img) {
    ctx.drawImage(img, enemy.x, enemy.y, enemy.w, enemy.h);
  }
}

/* ------------- Обновление состояния ------------- */
function update() {
  // Движение и поворот
  if (keys['ArrowRight']) {
    ken.x += ken.vx;
    ken.action = 'walk';
    ken.facing = 'right';
  } else if (keys['ArrowLeft']) {
    ken.x -= ken.vx;
    ken.action = 'walk';
    ken.facing = 'left';
  } else {
    if (ken.action !== 'punch') ken.action = 'idle';
  }

  ken.x = Math.max(0, Math.min(canvas.width - ken.w, ken.x));

  // Удар
  if (keys['Space']) {
    if (ken.action !== 'punch') {
      ken.action = 'punch';
      
      // Проверка попадания по врагам в зависимости от уровня
      if (page === 2 && enemies.level2.alive && isColliding(ken, enemies.level2)) {
        enemies.level2.hp -= 1;
        enemies.level2.action = 'punch';
        enemies.level2.hitTimer = 20;
        
        if (enemies.level2.hp <= 0) {
          enemies.level2.alive = false;
          enemies.level2.action = 'death';
        }
      }
      
      if (page === 3) {
        enemies.level3.forEach(enemy => {
          if (enemy.alive && isColliding(ken, enemy)) {
            enemy.hp -= 1;
            enemy.action = 'punch';
            enemy.hitTimer = 20;
            
            if (enemy.hp <= 0) {
              enemy.alive = false;
              enemy.action = 'death';
            }
          }
        });
      }
      
      setTimeout(() => { 
        if (ken.action === 'punch') ken.action = 'idle'; 
      }, 220);
    }
    keys['Space'] = false;
  }

  // Эффект попадания по врагам
  if (page === 2) {
    if (enemies.level2.hitTimer > 0) {
      enemies.level2.hitTimer--;
      if (enemies.level2.hitTimer === 0 && enemies.level2.alive) {
        enemies.level2.action = 'idle';
      }
    }
  }
  
  if (page === 3) {
    enemies.level3.forEach(enemy => {
      if (enemy.hitTimer > 0) {
        enemy.hitTimer--;
        if (enemy.hitTimer === 0 && enemy.alive) {
          enemy.action = 'idle';
        }
      }
    });
  }

  // Переход между уровнями
  if (page === 1 && ken.x >= canvas.width - ken.w - 10) {
    page = 2;
    ken.x = 40;
  }
  
  if (page === 2 && ken.x >= canvas.width - ken.w - 10 && !enemies.level2.alive) {
    page = 3;
    ken.x = 40;
  }
}

/* ------------- Рендер сцены ------------- */
function render() {
  // Фон в зависимости от уровня
  const bg = (page === 1) ? images.back1 : 
             (page === 2) ? images.back2 : images.back3;
             
  if (bg) {
    ctx.drawImage(bg, 0, 0, canvas.width, canvas.height);
  } else {
    ctx.fillStyle = page === 1 ? '#446' : 
                   page === 2 ? '#264' : '#624';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  // UI
  ctx.fillStyle = 'rgba(0,0,0,0.6)'; 
  ctx.fillRect(8, 8, 120, 40);
  ctx.fillStyle = '#fff'; 
  ctx.font = '16px monospace';
  ctx.fillText('Уровень: ' + page, 12, 26);
  
  if (page === 2 && enemies.level2.alive) {
    ctx.fillText('HP: ' + enemies.level2.hp, 12, 50);
  }
  
  if (page === 3) {
    const aliveEnemies = enemies.level3.filter(e => e.alive).length;
    ctx.fillText('Врагов: ' + aliveEnemies, 12, 50);
  }
  // Персонажи
  drawKen();
  
  // Враги в зависимости от уровня
  if (page === 2) {
    drawEnemy(enemies.level2);
  } else if (page === 3) {
    enemies.level3.forEach(enemy => {
      drawEnemy(enemy);
    });
  }
}

/* ------------- Игровой цикл ------------- */
function loop() {
  update();
  render();
  requestAnimationFrame(loop);
}

/* ------------- Старт ------------- */
preloadAll().then(() => {
  overlay.style.display = 'none';
  loop();
});
</script>
</body>
</html>

